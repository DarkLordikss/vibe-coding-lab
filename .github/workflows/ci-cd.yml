name: CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  DOCKER_IMAGE: hospital-management-app
  DOCKER_TAG: ${{ github.sha }}

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build Docker image
      run: |
        docker build -t ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} -t ${{ env.DOCKER_IMAGE }}:latest .
    
    - name: Save Docker image
      run: |
        docker save ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} | gzip > image.tar.gz
    
    - name: Upload Docker image artifact
      uses: actions/upload-artifact@v4
      with:
        name: docker-image
        path: image.tar.gz
        retention-days: 1

  unit-tests:
    name: Run Unit Tests
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run unit tests
      env:
        REDIS_HOST: localhost
        REDIS_PORT: 6379
      run: |
        set -e
        python -m unittest test_main -v || {
          echo "‚ùå Unit tests failed!"
          exit 1
        }
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: |
          test-results.xml
        if-no-files-found: ignore

  docker-tests:
    name: Run Tests in Docker
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download Docker image
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: .
    
    - name: Load Docker image
      run: |
        gunzip -c image.tar.gz | docker load
    
    - name: Build test image
      run: |
        docker build -f Dockerfile.test -t ${{ env.DOCKER_IMAGE }}-test:${{ env.DOCKER_TAG }} .
    
    - name: Start Redis container
      run: |
        docker run -d --name redis-test \
          -p 6379:6379 \
          --health-cmd="redis-cli ping" \
          --health-interval=5s \
          --health-timeout=3s \
          --health-retries=5 \
          redis:7-alpine
    
    - name: Wait for Redis to be ready
      run: |
        timeout 30 bash -c 'until docker exec redis-test redis-cli ping; do sleep 1; done'
    
    - name: Run unit tests in Docker
      env:
        REDIS_HOST: redis-test
        REDIS_PORT: 6379
      run: |
        set -e
        docker run --rm \
          --network host \
          -e REDIS_HOST=localhost \
          -e REDIS_PORT=6379 \
          ${{ env.DOCKER_IMAGE }}-test:${{ env.DOCKER_TAG }} \
          python -m unittest test_main -v || {
            echo "‚ùå Docker tests failed!"
            exit 1
          }
    
    - name: Cleanup
      if: always()
      run: |
        docker stop redis-test || true
        docker rm redis-test || true

  load-tests:
    name: Load Testing with Locust
    runs-on: ubuntu-latest
    needs: [build, unit-tests]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download Docker image
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: .
    
    - name: Load Docker image
      run: |
        gunzip -c image.tar.gz | docker load
    
    - name: Build test image
      run: |
        docker build -f Dockerfile.test -t ${{ env.DOCKER_IMAGE }}-test:${{ env.DOCKER_TAG }} .
    
    - name: Start Redis container
      run: |
        docker run -d --name redis-loadtest \
          -p 6379:6379 \
          --health-cmd="redis-cli ping" \
          --health-interval=5s \
          --health-timeout=3s \
          --health-retries=5 \
          redis:7-alpine
    
    - name: Wait for Redis to be ready
      run: |
        timeout 30 bash -c 'until docker exec redis-loadtest redis-cli ping; do sleep 1; done'
    
    - name: Start application container
      run: |
        docker run -d --name app-loadtest \
          --network host \
          -e REDIS_HOST=localhost \
          -e REDIS_PORT=6379 \
          -e TORNADO_AUTORELOAD=false \
          -e TORNADO_DEBUG=false \
          -p 8888:8888 \
          ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
    
    - name: Wait for application to be ready
      run: |
        timeout 30 bash -c 'until curl -f http://localhost:8888/; do sleep 1; done'
    
    - name: Run load tests
      run: |
        set -e
        docker run --rm \
          --network host \
          -e REDIS_HOST=localhost \
          -e REDIS_PORT=6379 \
          ${{ env.DOCKER_IMAGE }}-test:${{ env.DOCKER_TAG }} \
          locust -f load_test.py \
            --host=http://localhost:8888 \
            --users=10 \
            --spawn-rate=2 \
            --run-time=30s \
            --headless \
            --html=load_test_report.html \
            --csv=load_test_results || {
              echo "‚ùå Load tests failed!"
              exit 1
            }
    
    - name: Upload load test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: load-test-results
        path: |
          load_test_report.html
          load_test_results*.csv
        if-no-files-found: ignore
    
    - name: Cleanup
      if: always()
      run: |
        docker stop app-loadtest redis-loadtest || true
        docker rm app-loadtest redis-loadtest || true

  deploy:
    name: Deploy to VM (Mock)
    runs-on: ubuntu-latest
    needs: [build, unit-tests, docker-tests, load-tests]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download Docker image
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: .
    
    - name: Load Docker image
      run: |
        gunzip -c image.tar.gz | docker load
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
    
    - name: Backup current deployment
      env:
        SSH_HOST: ${{ secrets.SSH_HOST }}
        SSH_USER: ${{ secrets.SSH_USER }}
        SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
      run: |
        echo "üíæ Backing up current deployment..."
        ssh -p $SSH_PORT -i ~/.ssh/id_rsa $SSH_USER@$SSH_HOST << 'EOF' || echo "‚ö†Ô∏è  No previous deployment to backup"
          set -e
          cd /tmp/deploy || exit 0
          
          # Save current image if exists
          if docker images | grep -q "${{ env.DOCKER_IMAGE }}:latest"; then
            echo "üì¶ Saving current image..."
            docker save ${{ env.DOCKER_IMAGE }}:latest | gzip > /tmp/deploy/previous-image.tar.gz
            echo "‚úÖ Backup saved"
          else
            echo "‚ÑπÔ∏è  No previous image found"
          fi
        EOF
    
    - name: Deploy to VM (Mock)
      id: deploy
      env:
        SSH_HOST: ${{ secrets.SSH_HOST }}
        SSH_USER: ${{ secrets.SSH_USER }}
        SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
      run: |
        set -e
        echo "üöÄ Starting deployment to VM..."
        
        # Mock deployment steps
        echo "üì¶ Preparing deployment package..."
        docker save ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} | gzip > deploy-image.tar.gz
        
        echo "üì§ Uploading to VM..."
        scp -P $SSH_PORT -i ~/.ssh/id_rsa \
          deploy-image.tar.gz \
          docker-compose.yml \
          scripts/deploy.sh \
          scripts/rollback.sh \
          $SSH_USER@$SSH_HOST:/tmp/deploy/ || {
            echo "‚ùå Failed to upload files to VM"
            exit 1
          }
        
        echo "üîß Setting up on VM..."
        ssh -p $SSH_PORT -i ~/.ssh/id_rsa $SSH_USER@$SSH_HOST << 'EOF' || {
          echo "‚ùå Deployment failed on VM"
          exit 1
        }
          set -e
          cd /tmp/deploy
          
          # Make scripts executable
          chmod +x deploy.sh rollback.sh || true
          
          # Run deployment script
          ./deploy.sh || {
            echo "‚ùå Deployment script failed!"
            docker-compose logs
            exit 1
          }
        EOF
        
        echo "‚úÖ Deployment finished"
    
    - name: Verify deployment
      id: verify
      env:
        SSH_HOST: ${{ secrets.SSH_HOST }}
        SSH_USER: ${{ secrets.SSH_USER }}
        SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
      run: |
        set -e
        echo "üîç Verifying deployment..."
        
        MAX_RETRIES=5
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if ssh -p $SSH_PORT -i ~/.ssh/id_rsa $SSH_USER@$SSH_HOST << 'EOF'
            set -e
            # Check containers
            if ! docker ps | grep -qE "(app|redis)"; then
              echo "‚ùå Containers not running"
              exit 1
            fi
            
            # Check application
            if ! curl -f http://localhost:8888/ > /dev/null 2>&1; then
              echo "‚ùå Application not responding"
              exit 1
            fi
            
            # Check analytics endpoint
            if ! curl -f http://localhost:8888/analytics > /dev/null 2>&1; then
              echo "‚ùå Analytics endpoint not responding"
              exit 1
            fi
            
            echo "‚úÖ All checks passed"
          EOF
          then
            echo "‚úÖ Deployment verification successful"
            exit 0
          fi
          
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "‚è≥ Retry $RETRY_COUNT/$MAX_RETRIES..."
          sleep 5
        done
        
        echo "‚ùå Deployment verification failed after $MAX_RETRIES retries"
        exit 1
    
    - name: Cleanup SSH keys
      if: always()
      run: |
        rm -f ~/.ssh/id_rsa

  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [deploy]
    if: failure() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
    
    - name: Rollback to previous version
      env:
        SSH_HOST: ${{ secrets.SSH_HOST }}
        SSH_USER: ${{ secrets.SSH_USER }}
        SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
      run: |
        set -e
        echo "üîÑ Starting rollback to previous version..."
        
        ssh -p $SSH_PORT -i ~/.ssh/id_rsa $SSH_USER@$SSH_HOST << 'EOF' || {
          echo "‚ö†Ô∏è  Rollback failed - no previous version available"
          exit 0
        }
          set -e
          cd /tmp/deploy
          
          # Make rollback script executable
          chmod +x rollback.sh || true
          
          # Run rollback script
          ./rollback.sh || {
            echo "‚ùå Rollback script failed!"
            docker-compose logs
            exit 1
          }
        EOF
    
    - name: Cleanup SSH keys
      if: always()
      run: |
        rm -f ~/.ssh/id_rsa

  summary:
    name: CI/CD Summary
    runs-on: ubuntu-latest
    needs: [build, unit-tests, docker-tests, load-tests, deploy, rollback]
    if: always() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch')
    
    steps:
    - name: Print summary
      run: |
        echo "## CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Unit Tests | ${{ needs.unit-tests.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Docker Tests | ${{ needs.docker-tests.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Load Tests | ${{ needs.load-tests.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Deploy | ${{ needs.deploy.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Rollback | ${{ needs.rollback.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check if pipeline failed
        if [ "${{ needs.unit-tests.result }}" != "success" ] || \
           [ "${{ needs.docker-tests.result }}" != "success" ] || \
           [ "${{ needs.load-tests.result }}" != "success" ]; then
          echo "‚ùå **Pipeline failed due to test failures**" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ needs.deploy.result }}" == "failure" ]; then
          echo "‚ö†Ô∏è  **Deployment failed - rollback attempted**" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "‚úÖ **Pipeline completed successfully**" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY

